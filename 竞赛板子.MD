# 算法
```c++
// 递归版欧几里得算法
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

```c++
int find(int x) {
    return x == parent[x] ? x : parent[x] = find(parent[x]);
}
```

```c++
#include <bits/stdc++.h>
using namespace std;

// Fenwick Tree / BIT：1-indexed
struct Fenwick {
    int n;
    vector<long long> bit; // 存计数，用 long long 更稳妥
    Fenwick(int n = 0) { init(n); }
    void init(int n_) { n = n_; bit.assign(n + 1, 0); }
    // 在 idx 位置加 val
    void add(int idx, long long val) {
        for (; idx <= n; idx += idx & -idx) bit[idx] += val;
    }
    // 查询前缀和 [1..idx]
    long long sum(int idx) const {
        long long r = 0;
        for (; idx > 0; idx -= idx & -idx) r += bit[idx];
        return r;
    }
    // 查询区间和 [l..r]
    long long rangeSum(int l, int r) const {
        if (l > r) return 0;
        return sum(r) - sum(l - 1);
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    if (!(cin >> n)) return 0;
    vector<long long> a(n);
    for (int i = 0; i < n; ++i) cin >> a[i];

    // 坐标压缩
    vector<long long> vals = a;
    sort(vals.begin(), vals.end());
    vals.erase(unique(vals.begin(), vals.end()), vals.end());
    auto getRank = [&](long long x) {
        return int(lower_bound(vals.begin(), vals.end(), x) - vals.begin()) + 1; // 1-based
    };

    Fenwick ft((int)vals.size());
    long long ans = 0;
    for (int j = 0; j < n; ++j) {
        int rk = getRank(a[j]);
        long long seen = ft.sum((int)vals.size()); // 已出现总数
        long long le   = ft.sum(rk);               // ≤ a[j] 的个数
        ans += (seen - le);                        // > a[j] 的个数
        ft.add(rk, 1);                             // 记录 a[j] 已出现
    }

    cout << ans << '\n';
    return 0;
}
```